{"id":"node_modules/@popmotion/popcorn/dist/popcorn.es.js","dependencies":[{"name":"/home/kusti8/Documents/Github/webmaster2019/package.json","includedInParent":true,"mtime":1553113739742},{"name":"/home/kusti8/Documents/Github/webmaster2019/.babelrc","includedInParent":true,"mtime":1553111962055},{"name":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/popcorn/package.json","includedInParent":true,"mtime":1553111896500},{"name":"style-value-types","loc":{"line":1,"column":48},"parent":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/popcorn/dist/popcorn.es.js","resolved":"/home/kusti8/Documents/Github/webmaster2019/node_modules/style-value-types/dist/style-value-types.es.js"},{"name":"hey-listen","loc":{"line":2,"column":26},"parent":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/popcorn/dist/popcorn.es.js","resolved":"/home/kusti8/Documents/Github/webmaster2019/node_modules/hey-listen/dist/hey-listen.es.js"},{"name":"framesync","loc":{"line":3,"column":29},"parent":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/popcorn/dist/popcorn.es.js","resolved":"/home/kusti8/Documents/Github/webmaster2019/node_modules/framesync/dist/framesync.es.js"},{"name":"@popmotion/easing","loc":{"line":5,"column":204},"parent":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/popcorn/dist/popcorn.es.js","resolved":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/easing/dist/easing.es.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"createAnticipateEasing\", {\n  enumerable: true,\n  get: function () {\n    return _easing.createAnticipateEasing;\n  }\n});\nObject.defineProperty(exports, \"createBackIn\", {\n  enumerable: true,\n  get: function () {\n    return _easing.createBackIn;\n  }\n});\nObject.defineProperty(exports, \"createExpoIn\", {\n  enumerable: true,\n  get: function () {\n    return _easing.createExpoIn;\n  }\n});\nObject.defineProperty(exports, \"cubicBezier\", {\n  enumerable: true,\n  get: function () {\n    return _easing.cubicBezier;\n  }\n});\nObject.defineProperty(exports, \"linear\", {\n  enumerable: true,\n  get: function () {\n    return _easing.linear;\n  }\n});\nObject.defineProperty(exports, \"easeIn\", {\n  enumerable: true,\n  get: function () {\n    return _easing.easeIn;\n  }\n});\nObject.defineProperty(exports, \"easeOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.easeOut;\n  }\n});\nObject.defineProperty(exports, \"easeInOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.easeInOut;\n  }\n});\nObject.defineProperty(exports, \"circIn\", {\n  enumerable: true,\n  get: function () {\n    return _easing.circIn;\n  }\n});\nObject.defineProperty(exports, \"circOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.circOut;\n  }\n});\nObject.defineProperty(exports, \"circInOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.circInOut;\n  }\n});\nObject.defineProperty(exports, \"backIn\", {\n  enumerable: true,\n  get: function () {\n    return _easing.backIn;\n  }\n});\nObject.defineProperty(exports, \"backOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.backOut;\n  }\n});\nObject.defineProperty(exports, \"backInOut\", {\n  enumerable: true,\n  get: function () {\n    return _easing.backInOut;\n  }\n});\nObject.defineProperty(exports, \"anticipate\", {\n  enumerable: true,\n  get: function () {\n    return _easing.anticipate;\n  }\n});\nObject.defineProperty(exports, \"reversed\", {\n  enumerable: true,\n  get: function () {\n    return _easing.reversed;\n  }\n});\nObject.defineProperty(exports, \"mirrored\", {\n  enumerable: true,\n  get: function () {\n    return _easing.mirrored;\n  }\n});\nexports.wrap = exports.velocityPerSecond = exports.velocityPerFrame = exports.toDecimal = exports.steps = exports.springForceLinear = exports.springForceExpo = exports.springForce = exports.snap = exports.smoothFrame = exports.smooth = exports.radiansToDegrees = exports.progress = exports.pointFromVector = exports.pipe = exports.mixComplex = exports.mixColor = exports.mixArray = exports.mix = exports.isPoint3D = exports.isPoint = exports.interpolate = exports.distance = exports.degreesToRadians = exports.conditional = exports.clamp = exports.applyOffset = exports.angle = void 0;\n\nvar _styleValueTypes = require(\"style-value-types\");\n\nvar _heyListen = require(\"hey-listen\");\n\nvar _framesync = require(\"framesync\");\n\nvar _easing = require(\"@popmotion/easing\");\n\nvar zeroPoint = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nvar isNum = function (v) {\n  return typeof v === 'number';\n};\n\nvar radiansToDegrees = function (radians) {\n  return radians * 180 / Math.PI;\n};\n\nexports.radiansToDegrees = radiansToDegrees;\n\nvar angle = function (a, b) {\n  if (b === void 0) {\n    b = zeroPoint;\n  }\n\n  return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexports.angle = angle;\n\nvar applyOffset = function (from, to) {\n  var hasReceivedFrom = true;\n\n  if (to === undefined) {\n    to = from;\n    hasReceivedFrom = false;\n  }\n\n  return function (v) {\n    if (hasReceivedFrom) {\n      return v - from + to;\n    } else {\n      from = v;\n      hasReceivedFrom = true;\n      return to;\n    }\n  };\n};\n\nexports.applyOffset = applyOffset;\n\nvar curryRange = function (func) {\n  return function (min, max, v) {\n    return v !== undefined ? func(min, max, v) : function (cv) {\n      return func(min, max, cv);\n    };\n  };\n};\n\nvar clamp = function (min, max, v) {\n  return Math.min(Math.max(v, min), max);\n};\n\nvar clamp$1 = curryRange(clamp);\nexports.clamp = clamp$1;\n\nvar conditional = function (check, apply) {\n  return function (v) {\n    return check(v) ? apply(v) : v;\n  };\n};\n\nexports.conditional = conditional;\n\nvar degreesToRadians = function (degrees) {\n  return degrees * Math.PI / 180;\n};\n\nexports.degreesToRadians = degreesToRadians;\n\nvar isPoint = function (point) {\n  return point.hasOwnProperty('x') && point.hasOwnProperty('y');\n};\n\nexports.isPoint = isPoint;\n\nvar isPoint3D = function (point) {\n  return isPoint(point) && point.hasOwnProperty('z');\n};\n\nexports.isPoint3D = isPoint3D;\n\nvar distance1D = function (a, b) {\n  return Math.abs(a - b);\n};\n\nvar distance = function (a, b) {\n  if (b === void 0) {\n    b = zeroPoint;\n  }\n\n  if (isNum(a) && isNum(b)) {\n    return distance1D(a, b);\n  } else if (isPoint(a) && isPoint(b)) {\n    var xDelta = distance1D(a.x, b.x);\n    var yDelta = distance1D(a.y, b.y);\n    var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n\n  return 0;\n};\n\nexports.distance = distance;\n\nvar progress = function (from, to, value) {\n  var toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexports.progress = progress;\n\nvar mix = function (from, to, progress) {\n  return -progress * from + progress * to + from;\n};\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nexports.mix = mix;\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar mixLinearColor = function (from, to, v) {\n  var fromExpo = from * from;\n  var toExpo = to * to;\n  return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);\n};\n\nvar colorTypes = [_styleValueTypes.hex, _styleValueTypes.rgba, _styleValueTypes.hsla];\n\nvar getColorType = function (v) {\n  return colorTypes.find(function (type) {\n    return type.test(v);\n  });\n};\n\nvar mixColor = function (from, to) {\n  var fromColorType = getColorType(from);\n  var toColorType = getColorType(to);\n  (0, _heyListen.invariant)(fromColorType.transform === toColorType.transform, 'Both colors must be Hex and/or RGBA, or both must be HSLA');\n  var fromColor = fromColorType.parse(from);\n  var toColor = toColorType.parse(to);\n\n  var blended = __assign({}, fromColor);\n\n  var mixFunc = fromColorType === _styleValueTypes.hsla ? mix : mixLinearColor;\n  return function (v) {\n    for (var key in blended) {\n      if (key !== 'alpha') {\n        blended[key] = mixFunc(fromColor[key], toColor[key], v);\n      }\n    }\n\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\nexports.mixColor = mixColor;\n\nvar combineFunctions = function (a, b) {\n  return function (v) {\n    return b(a(v));\n  };\n};\n\nvar pipe = function () {\n  var transformers = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    transformers[_i] = arguments[_i];\n  }\n\n  return transformers.reduce(combineFunctions);\n};\n\nexports.pipe = pipe;\n\nvar mixArray = function (from, to) {\n  var output = from.slice();\n  var numValues = output.length;\n  var blendValue = from.map(function (fromThis, i) {\n    var toThis = to[i];\n\n    if (isNum(fromThis)) {\n      return function (v) {\n        return mix(fromThis, toThis, v);\n      };\n    } else if (_styleValueTypes.color.test(fromThis)) {\n      return mixColor(fromThis, toThis);\n    } else {\n      return mixComplex(fromThis, toThis);\n    }\n  });\n  return function (v) {\n    for (var i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nexports.mixArray = mixArray;\n\nvar mixComplex = function (from, to) {\n  var valueTemplate = _styleValueTypes.complex.createTransformer(from);\n\n  (0, _heyListen.invariant)(valueTemplate(from) === _styleValueTypes.complex.createTransformer(to)(from), \"Values '\" + from + \"' and '\" + to + \"' are of different format, or a value might have changed value type.\");\n  return pipe(mixArray(_styleValueTypes.complex.parse(from), _styleValueTypes.complex.parse(to)), valueTemplate);\n};\n\nexports.mixComplex = mixComplex;\nvar mixNumber = curryRange(mix);\n\nvar getMixer = function (v) {\n  return typeof v === 'number' ? mixNumber : _styleValueTypes.color.test(v) ? mixColor : mixComplex;\n};\n\nvar createMixers = function (output, ease) {\n  return Array(output.length - 1).fill(getMixer(output[0])).map(function (factory, i) {\n    var mixer = factory(output[i], output[i + 1]);\n\n    if (ease) {\n      var easingFunction = Array.isArray(ease) ? ease[i] : ease;\n      return pipe(easingFunction, mixer);\n    } else {\n      return mixer;\n    }\n  });\n};\n\nvar fastInterpolate = function (_a, _b) {\n  var from = _a[0],\n      to = _a[1];\n  var mixer = _b[0];\n  return function (v) {\n    return mixer(progress(from, to, v));\n  };\n};\n\nvar slowInterpolate = function (input, mixers) {\n  var inputLength = input.length;\n  var lastInputIndex = inputLength - 1;\n  return function (v) {\n    var mixerIndex = 0;\n    var foundMixerIndex = false;\n\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n\n    if (!foundMixerIndex) {\n      var i = 1;\n\n      for (; i < inputLength; i++) {\n        if (input[i] > v || i === lastInputIndex) {\n          break;\n        }\n      }\n\n      mixerIndex = i - 1;\n    }\n\n    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n};\n\nvar interpolate = function (input, output, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.clamp,\n      clamp = _c === void 0 ? true : _c,\n      ease = _b.ease;\n\n  var inputLength = input.length;\n  (0, _heyListen.invariant)(inputLength === output.length, 'Both input and output ranges must be the same length');\n  (0, _heyListen.invariant)(!ease || !Array.isArray(ease) || ease.length === input.length - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n\n  if (input[0] > input[inputLength - 1]) {\n    input = input.slice();\n    output = output.slice();\n    input.reverse();\n    output.reverse();\n  }\n\n  var mixers = createMixers(output, ease);\n  var interpolate = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return clamp ? pipe(clamp$1(input[0], input[inputLength - 1]), interpolate) : interpolate;\n};\n\nexports.interpolate = interpolate;\n\nvar pointFromVector = function (origin, angle, distance) {\n  angle = degreesToRadians(angle);\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\nexports.pointFromVector = pointFromVector;\n\nvar toDecimal = function (num, precision) {\n  if (precision === void 0) {\n    precision = 2;\n  }\n\n  precision = Math.pow(10, precision);\n  return Math.round(num * precision) / precision;\n};\n\nexports.toDecimal = toDecimal;\n\nvar smoothFrame = function (prevValue, nextValue, duration, smoothing) {\n  if (smoothing === void 0) {\n    smoothing = 0;\n  }\n\n  return toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));\n};\n\nexports.smoothFrame = smoothFrame;\n\nvar smooth = function (strength) {\n  if (strength === void 0) {\n    strength = 50;\n  }\n\n  var previousValue = 0;\n  var lastUpdated = 0;\n  return function (v) {\n    var currentFramestamp = (0, _framesync.getFrameData)().timestamp;\n    var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n    var newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nexports.smooth = smooth;\n\nvar snap = function (points) {\n  if (typeof points === 'number') {\n    return function (v) {\n      return Math.round(v / points) * points;\n    };\n  } else {\n    var i_1 = 0;\n    var numPoints_1 = points.length;\n    return function (v) {\n      var lastDistance = Math.abs(points[0] - v);\n\n      for (i_1 = 1; i_1 < numPoints_1; i_1++) {\n        var point = points[i_1];\n        var distance = Math.abs(point - v);\n        if (distance === 0) return point;\n        if (distance > lastDistance) return points[i_1 - 1];\n        if (i_1 === numPoints_1 - 1) return point;\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\nexports.snap = snap;\n\nvar identity = function (v) {\n  return v;\n};\n\nvar springForce = function (alterDisplacement) {\n  if (alterDisplacement === void 0) {\n    alterDisplacement = identity;\n  }\n\n  return curryRange(function (constant, origin, v) {\n    var displacement = origin - v;\n    var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n    return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n  });\n};\n\nexports.springForce = springForce;\nvar springForceLinear = springForce();\nexports.springForceLinear = springForceLinear;\nvar springForceExpo = springForce(Math.sqrt);\nexports.springForceExpo = springForceExpo;\n\nvar velocityPerFrame = function (xps, frameDuration) {\n  return isNum(xps) ? xps / (1000 / frameDuration) : 0;\n};\n\nexports.velocityPerFrame = velocityPerFrame;\n\nvar velocityPerSecond = function (velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n};\n\nexports.velocityPerSecond = velocityPerSecond;\n\nvar wrap = function (min, max, v) {\n  var rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nvar wrap$1 = curryRange(wrap);\nexports.wrap = wrap$1;\nvar clampProgress = clamp$1(0, 1);\n\nvar steps = function (steps, direction) {\n  if (direction === void 0) {\n    direction = 'end';\n  }\n\n  return function (progress) {\n    progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n    var expanded = progress * steps;\n    var rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n    return clampProgress(rounded / steps);\n  };\n};\n\nexports.steps = steps;"},"sourceMaps":null,"error":null,"hash":"279b323d78000694c608da3c98c0c434","cacheData":{"env":{}}}