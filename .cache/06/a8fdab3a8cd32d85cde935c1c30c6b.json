{"id":"node_modules/@popmotion/easing/dist/easing.es.js","dependencies":[{"name":"/home/kusti8/Documents/Github/webmaster2019/package.json","includedInParent":true,"mtime":1553113739742},{"name":"/home/kusti8/Documents/Github/webmaster2019/.babelrc","includedInParent":true,"mtime":1553111962055},{"name":"/home/kusti8/Documents/Github/webmaster2019/node_modules/@popmotion/easing/package.json","includedInParent":true,"mtime":1553111896068}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cubicBezier = cubicBezier;\nexports.anticipate = exports.backInOut = exports.backOut = exports.backIn = exports.circInOut = exports.circOut = exports.circIn = exports.easeInOut = exports.easeOut = exports.easeIn = exports.linear = exports.createAnticipateEasing = exports.createBackIn = exports.createExpoIn = exports.createMirroredEasing = exports.createReversedEasing = exports.mirrored = exports.reversed = void 0;\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\n\nvar reversed = function (easing) {\n  return function (p) {\n    return 1 - easing(1 - p);\n  };\n};\n\nexports.reversed = reversed;\n\nvar mirrored = function (easing) {\n  return function (p) {\n    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n  };\n};\n\nexports.mirrored = mirrored;\nvar createReversedEasing = reversed;\nexports.createReversedEasing = createReversedEasing;\nvar createMirroredEasing = mirrored;\nexports.createMirroredEasing = createMirroredEasing;\n\nvar createExpoIn = function (power) {\n  return function (p) {\n    return Math.pow(p, power);\n  };\n};\n\nexports.createExpoIn = createExpoIn;\n\nvar createBackIn = function (power) {\n  return function (p) {\n    return p * p * ((power + 1) * p - power);\n  };\n};\n\nexports.createBackIn = createBackIn;\n\nvar createAnticipateEasing = function (power) {\n  var backEasing = createBackIn(power);\n  return function (p) {\n    return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n  };\n};\n\nexports.createAnticipateEasing = createAnticipateEasing;\n\nvar linear = function (p) {\n  return p;\n};\n\nexports.linear = linear;\nvar easeIn =\n/*#__PURE__*/\ncreateExpoIn(2);\nexports.easeIn = easeIn;\nvar easeOut =\n/*#__PURE__*/\nreversed(easeIn);\nexports.easeOut = easeOut;\nvar easeInOut =\n/*#__PURE__*/\nmirrored(easeIn);\nexports.easeInOut = easeInOut;\n\nvar circIn = function (p) {\n  return 1 - Math.sin(Math.acos(p));\n};\n\nexports.circIn = circIn;\nvar circOut =\n/*#__PURE__*/\nreversed(circIn);\nexports.circOut = circOut;\nvar circInOut =\n/*#__PURE__*/\nmirrored(circOut);\nexports.circInOut = circInOut;\nvar backIn =\n/*#__PURE__*/\ncreateBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nexports.backIn = backIn;\nvar backOut =\n/*#__PURE__*/\nreversed(backIn);\nexports.backOut = backOut;\nvar backInOut =\n/*#__PURE__*/\nmirrored(backIn);\nexports.backInOut = backInOut;\nvar anticipate =\n/*#__PURE__*/\ncreateAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);\nexports.anticipate = anticipate;\nvar NEWTON_ITERATIONS = 8;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar K_SPLINE_TABLE_SIZE = 11;\nvar K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);\nvar FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';\n\nvar a = function (a1, a2) {\n  return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\n\nvar b = function (a1, a2) {\n  return 3.0 * a2 - 6.0 * a1;\n};\n\nvar c = function (a1) {\n  return 3.0 * a1;\n};\n\nvar getSlope = function (t, a1, a2) {\n  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\n\nvar calcBezier = function (t, a1, a2) {\n  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);\n\n  var binarySubdivide = function (aX, aA, aB) {\n    var i = 0;\n    var currentX;\n    var currentT;\n\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n    return currentT;\n  };\n\n  var newtonRaphsonIterate = function (aX, aGuessT) {\n    var i = 0;\n    var currentSlope = 0;\n    var currentX;\n\n    for (; i < NEWTON_ITERATIONS; ++i) {\n      currentSlope = getSlope(aGuessT, mX1, mX2);\n\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n\n      currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n\n    return aGuessT;\n  };\n\n  var calcSampleValues = function () {\n    for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {\n      sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);\n    }\n  };\n\n  var getTForX = function (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = K_SPLINE_TABLE_SIZE - 1;\n    var dist = 0.0;\n    var guessForT = 0.0;\n    var initialSlope = 0.0;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += K_SAMPLE_STEP_SIZE;\n    }\n\n    --currentSample;\n    dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;\n    initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);\n    }\n  };\n\n  calcSampleValues();\n\n  var resolver = function (aX) {\n    var returnValue;\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      returnValue = aX;\n    } else if (aX === 0) {\n      returnValue = 0;\n    } else if (aX === 1) {\n      returnValue = 1;\n    } else {\n      returnValue = calcBezier(getTForX(aX), mY1, mY2);\n    }\n\n    return returnValue;\n  };\n\n  return resolver;\n}"},"sourceMaps":null,"error":null,"hash":"b01d13c20641123da376ec1cb6217c79","cacheData":{"env":{}}}